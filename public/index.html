<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Connecting up Google Cardboard to web APIs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
        overflow: hidden;
      }
      #webglviewer {
        bottom: 0;
        left: 0;
        position: absolute;
        right: 0;
        top: 0;
      }
    </style>
  </head>
  <body>
    <div id="webglviewer"></div>

    <script src="./js/three.min.js"></script>
    <script src="./js/StereoEffect.js"></script>
    <script src="./js/DeviceOrientationControls.js"></script>
    <script src="./js/OrbitControls.js"></script>
    <script src="./js/helvetiker_regular.typeface.js"></script>
    <script src="/socket.io/socket.io.js"></script>

    <script>
      var scene,
          camera, 
          renderer,
          element,
          container,
          effect,
          controls,
          clock,

          // Particles
          totalParticles = 160,
          maxParticleSize = 200,
          particleRotationSpeed = 0,
          particleRotationDeg = 0,
          lastColorRange = [0, 0.3],
          currentColorRange = [0, 0.3],

          // Viewer
          viewer,
          viewerTexture,
          viewers = [], // All our sparkling things

          // Text display
          tweetText = new THREE.TextGeometry(),
          tweetTextMesh = new THREE.Mesh(),

          // Twitter API set up
          tweets = [],

          clock = new THREE.Clock(),

          socket = io();

      init();

      socket.on('tweet', function(tweet) {
        //console.log('Tweet was ', tweet);
        console.log(tweet.text.length);
        generateViewer({
          color: parseInt('0x'+ tweet.user.profile_background_color),
          texture: viewerTexture,
          dimensions: {
            x: 98,
            y: 48
          },
          scene: scene,
          startingCoords: {
            x: getRandomArbitrary(-500, 500),
            y: 0,
            z: getRandomArbitrary(-500, 500)
          },
          speed: {
            x: 10,
            y: 10,
            z: 10
          },
          size: {
            x: 50,
            y: (tweet.text.length / 140) * 100,
            z: 50
          },
          groupCoords: {
            x: 40,
            y: 10,
            z: 0
          },
          rotation: {
            x: 0,
            y: 0,
            z: 0
          },
          startTime: clock.getElapsedTime()
        });
      });

      function initViewerDefaults() {
        var viewerTexture = THREE.ImageUtils.loadTexture('textures/pixelalpha.png'),
            viewerMaterial = new THREE.SpriteMaterial({
              map: viewerTexture,
              color: 0xffffff
            });
        viewerTexture.wrapS = THREE.RepeatWrapping;
        viewerTexture.wrapT = THREE.RepeatWrapping;
        viewerTexture.repeat.set(64, 64);
      }

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.001, 700);
        camera.position.set(0, 15, 0);
        scene.add(camera);

        renderer = new THREE.WebGLRenderer();
        element = renderer.domElement;
        container = document.getElementById('webglviewer');
        container.appendChild(element);

        effect = new THREE.StereoEffect(renderer);

        // Our initial control fallback with mouse/touch events in case DeviceOrientation is not enabled
        controls = new THREE.OrbitControls(camera, element);
        controls.target.set(
          camera.position.x + 0.15,
          camera.position.y,
          camera.position.z
        );
        controls.noPan = true;
        controls.noZoom = true;

        // Our preferred controls via DeviceOrientation
        function setOrientationControls(e) {
          if (!e.alpha) {
            return;
          }

          controls = new THREE.DeviceOrientationControls(camera, true);
          controls.connect();
          controls.update();

          element.addEventListener('click', fullscreen, false);

          window.removeEventListener('deviceorientation', setOrientationControls, true);
        }
        window.addEventListener('deviceorientation', setOrientationControls, true);

        // Lighting
        var light = new THREE.PointLight(0x999999, 2, 100);
        light.position.set(50, 50, 50);
        //scene.add(light);

        var lightScene = new THREE.PointLight(0x999999, 2, 100);
        lightScene.position.set(0, 5, 0);
        //scene.add(lightScene);

        initViewerDefaults();

        animate();
      }

      function generateViewer(options) {
        var viewerMaterial = new THREE.MeshBasicMaterial({
          color: options.color,
          specular: 0xffffff,
          alphaMap: options.texture
        });
        viewerMaterial.transparent = true;

        var particles = new THREE.Object3D();
        //var particles = new THREE.Geometry();

        var particleTexture = THREE.ImageUtils.loadTexture('textures/particle-new.png'),
            spriteMaterial = new THREE.SpriteMaterial({
            map: particleTexture,
            color: options.color
          });

        var particleMovements = [
          {
            start: 0,
            end: options.size.y,
            x: 0,
            y: options.speed.y,
            z: 0
          }
        ];
        var currentParticleDirection = 0,
            currentLinePos = 0,
            currentCoords = {x: 0, y: 0, z: 0},
            startingCoords = options.startingCoords;

        for (var i = 0; i < options.size.y; i++) {
          var sprite = new THREE.Sprite(spriteMaterial);

          sprite.scale.set(32, 32, 1.0);

          if (particleMovements[currentParticleDirection] && startingCoords) {
            // If we're outside the current particleMovement range and there's another particleMovement to go to, go there.
            if ((particleMovements[currentParticleDirection].start > i || particleMovements[currentParticleDirection].end < i) && currentParticleDirection + 1 < particleMovements.length) {
              currentParticleDirection++;
              startingCoords = currentCoords; // We want it to follow from where we last were.
              currentLinePos = 0;
            }

            currentCoords = {
              x: startingCoords.x + particleMovements[currentParticleDirection].x * currentLinePos,
              y: startingCoords.y + particleMovements[currentParticleDirection].y * currentLinePos,
              z: startingCoords.z + particleMovements[currentParticleDirection].z * currentLinePos
            }

            sprite.position.set(currentCoords.x, currentCoords.y, currentCoords.z);
          }

          sprite.material.blending = THREE.AdditiveBlending;

          //sprite.visible = false;
          
          particles.add(sprite);

          currentLinePos++; // Tracks the line position specifically
        }

        particles.position.y = 0;

        particles.position.set(options.groupCoords.x, options.groupCoords.y, options.groupCoords.z);

        particles.startTime = options.startTime;
        particles.height = options.size.y;
        particles.animationDone = false;

        viewers.push(particles);
        options.scene.add(particles);
      }

      function animate() {
        /*var elapsedSeconds = clock.getElapsedTime();

        for (var v = 0; v < viewers.length; v++) {
          var viewer = viewers[v];

          if (!viewer.animationDone) {
            for (var i = 0; i < viewer.height; i++) {
              if (i + viewer.startTime < elapsedSeconds * 60) {
                viewer.children[0].children[i].visible = true;

                if (i == viewer.height - 1) {
                  viewer.animationDone = true;
                }
              }
            }
          }
        }*/

        requestAnimationFrame(animate);

        update(clock.getDelta());
        render(clock.getDelta());
      }

      function resize() {
        var width = container.offsetWidth;
        var height = container.offsetHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        effect.setSize(width, height);
      }

      function update(dt) {
        resize();

        camera.updateProjectionMatrix();

        controls.update(dt);
      }

      function render(dt) {
        effect.render(scene, camera);
      }

      function fullscreen() {
        if (container.requestFullscreen) {
          container.requestFullscreen();
        } else if (container.msRequestFullscreen) {
          container.msRequestFullscreen();
        } else if (container.mozRequestFullScreen) {
          container.mozRequestFullScreen();
        } else if (container.webkitRequestFullscreen) {
          container.webkitRequestFullscreen();
        }
      }

      function getRandomArbitrary(min, max) {
        return Math.random() * (max - min) + min;
      }

      function getURL(url, callback) {
        var xmlhttp = new XMLHttpRequest();

        xmlhttp.onreadystatechange = function() {
          if (xmlhttp.readyState == 4) {
             if (xmlhttp.status == 200){
                 callback(JSON.parse(xmlhttp.responseText));
             }
             else {
                 console.log('We had an error, status code: ', xmlhttp.status);
             }
          }
        }

        xmlhttp.open('GET', url, true);
        xmlhttp.send();
      }
    </script>
  </body>
</html>
